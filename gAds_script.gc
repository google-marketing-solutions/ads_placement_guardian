/*
Copyright 2022 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Copyright 2022 Google LLC. This solution, including any related sample code or data, is made available on an “as is,” “as available,” and “with all faults” basis, solely for illustrative purposes, and without warranty or representation of any kind. This solution is experimental, unsupported and provided solely for your convenience. Your use of it is subject to your agreements with Google, as applicable, and may constitute a beta feature as defined under those agreements.  To the extent that you make any data available to Google in connection with your use of the solution, you represent and warrant that you have all necessary and appropriate rights, consents and permissions to permit Google to use and process that data.  By using any portion of this solution, you acknowledge, assume and accept all risks, known and unknown, associated with its usage, including with respect to your deployment of any portion of this solution in your systems, or usage in connection with your business, if at all.*

 * @name Spamming Placements
 *
 * @overview Alerts about placements (YT channels) which underperform.
 *
 * @author eladb@, xingj@
 * 2022/04/25
 * 
 */


//USER_TODO: Fill in
var SPREADSHEET_URL = "---";
var emails;

var spreadsheet;
var currentCustomerId;
var GO_BACK_DAYS_EARLY;
var GO_BACK_DAYS_LATE;

var EMAIL_SUBJECT;
var fromDate;
var toDate;
var accountDict = {};
var urlDict = {};

var CONSTS_GAds = {
  OUTPUT: 'Output',
  ADS_DATA_STATUS: 'ADS_DATA_STATUS',
  METRICS_FILTERS: 'METRICS_FILTERS',
  CHANNEL_IDS_COL: 'CHANNEL_IDS',
  HEADERS: 'HEADERS',
  YOUTUBE_TIMESTAMP_COL: 'YOUTUBE_TIMESTAMP',
  GO_BACK_DAYS_EARLY: 'GO_BACK_DAYS_EARLY',
  GO_BACK_DAYS_LATE: 'GO_BACK_DAYS_LATE',
  EMAIL_SUBJECT: 'EMAIL_SUBJECT',
  EMAILS: 'EMAILS',
  CHANNEL_IDS_HEADER: 'CHANNEL_IDS_HEADER'
};

const METRICS_DICTIONARY = {
  display_name: "Display Name",
  placement: "Placement",
  placement_type: "Placement Type",
  resource_name: "Resource Name",
  target_url: "Target URL",
  active_view_cpm: "Active View CPM",
  active_view_ctr: "Active View CTR",
  active_view_impressions: "Active View Impressions",
  active_view_measurability: "Active View Measurability",
  active_view_measurable_cost_micros: "Active View Measurable Cost (micros)",
  active_view_measurable_impressions: "Active View Measurable Impressions",
  active_view_viewability: "Active View Viewability",
  all_conversions: "All Conversions",
  all_conversions_from_interactions_rate: "All Conversions From Interactions Rate",
  all_conversions_value: "All Conversions Value",
  all_conversions_value_per_cost: "All Conversions Value Per Cost",
  average_cost: "Average Cost",
  average_cpc: "Average CPC",
  average_cpe: "Average CPE",
  average_cpm: "Average CPM",
  average_cpv: "Average CPV",
  clicks: "Clicks",
  conversions: "Conversions",
  conversions_from_interactions_rate: "Conversions from Interactions Rate",
  conversions_value: "Conversions Value",
  cost_micros: "Cost (micros)",
  cost_per_all_conversions: "Cost Per All Conversions",
  cost_per_conversion: "Cost Per Conversions",
  cross_device_conversions: "Cross Device Conversions",
  ctr: "CTR",
  engagement_rate: "Engagement Rate",
  engagements: "Engagements",
  impressions: "Impressions",
  interaction_event_types: "Interaction Event Types",
  interaction_rate: "Interaction Rate",
  interactions: "Interactions",
  value_per_all_conversions: "Value Per All Conversions",
  value_per_conversion: "Value Per Conversions",
  video_view_rate: "Video View Rate",
  video_views: "Video Views",
  view_through_conversions: "View Through Conversions"
};

const readableDictionary = {};
Object.keys(METRICS_DICTIONARY).forEach(key => {
    readableDictionary[METRICS_DICTIONARY[key].toLowerCase()] = "metrics." + key;
});

//USER_TODO: Rename to "main" if you run on CID only. Rename to "main_cid" otherwise
function main_cid() {
  spreadsheet = SpreadsheetApp.openByUrl(SPREADSHEET_URL);
  currentCustomerId = AdsApp.currentAccount().getCustomerId().replaceAll('-','');

  //Check if tab with this account ID exists, if not: exit and reminder to create tab with account ID
  if (!spreadsheet.getSheetByName(currentCustomerId)) {
    Logger.log("Please create tab in spreadsheet with this account ID as its name.");
    return;
  }

  spreadsheet.setSpreadsheetTimeZone(AdsApp.currentAccount().getTimeZone());
  GO_BACK_DAYS_EARLY = (spreadsheet.getRangeByName(currentCustomerId + '!' + CONSTS_GAds.GO_BACK_DAYS_EARLY)).getValue();
  GO_BACK_DAYS_LATE = (spreadsheet.getRangeByName(currentCustomerId + '!' + CONSTS_GAds.GO_BACK_DAYS_LATE)).getValue();
  fromDate = getDateStringForMinusDays(-1*GO_BACK_DAYS_EARLY);
  toDate = getDateStringForMinusDays(GO_BACK_DAYS_LATE);
  EMAIL_SUBJECT = (spreadsheet.getRangeByName(currentCustomerId + '!' + CONSTS_GAds.EMAIL_SUBJECT)).getValue();

  // Run queries for each of the queries entered in the spreadsheet
  var userConditions = createMetricsFilters();
  for (let i = 0; i < userConditions.length; i++) {
    storeReportResults(userConditions[i]);
  }

  if (Object.keys(accountDict).length > 0) {
    writeDataToGoogleSheet(accountDict, spreadsheet.getSheetByName(currentCustomerId));
  }
  sendEmail(urlDict);
}

function getDateStringForMinusDays(numDays) {
  var expectedDate = new Date(new Date().setDate(new Date().getDate() + numDays));
  return { 'query_date': getDateStringInTimeZone('yyyy-MM-dd', expectedDate), 'sheet_date': getDateStringInTimeZone('dd/MM/YY', expectedDate) };
}

/**
 * Produces a formatted string representing a given date in a given time zone.
 *
 * @param {string} format A format specifier for the string to be produced.
 * @param {date} date A date object. Defaults to the current date.
 * @param {string} timeZone A time zone. Defaults to the account's time zone.
 * @return {string} A formatted string of the given date in the given time zone.
 */
function getDateStringInTimeZone(format, date, timeZone) {
  date = date || new Date();
  timeZone = timeZone || AdsApp.currentAccount().getTimeZone();
  return Utilities.formatDate(date, timeZone, format);
}

//Changing human readable query terms to API readable query terms
function translateHumanToApiSyntax(text) {
  const reg = new RegExp(Object.keys(readableDictionary).join("|"), "gi");
  return text.toString().replace(reg, (matched) => readableDictionary[matched.toLowerCase()]);
}


function createMetricsFilters() {
  //Get values for metrics filters 
  var metricsFiltersQuery = [];
  var metricsFiltersValues = (spreadsheet.getRangeByName(currentCustomerId + '!' + CONSTS_GAds.METRICS_FILTERS)).getValues().filter(String);

  for (let i = 0; i < metricsFiltersValues.length; i++) {
    metricsFiltersQuery.push(translateHumanToApiSyntax(metricsFiltersValues[i]));
  }
  return metricsFiltersQuery;
}
    
function storeReportResults(conditionRow) { 
  //YT channel  
  //https://developers.google.com/google-ads/api/fields/v10/group_placement_view  

  var conditionRow = conditionRow;

  var query = 'SELECT \
    customer.id,\
    customer.descriptive_name,\
    group_placement_view.placement_type,\
    group_placement_view.display_name,\
    group_placement_view.placement,\
    group_placement_view.target_url,\
    metrics.impressions,\
    metrics.cost_micros,\
    metrics.conversions,\
    metrics.video_views,\
    metrics.video_view_rate,\
    metrics.clicks,\
    metrics.average_cpm,\
    metrics.ctr\
 FROM group_placement_view\
 WHERE\
    group_placement_view.placement_type IN ("YOUTUBE_CHANNEL")\
    AND campaign.advertising_channel_type = "VIDEO"\
    AND segments.date BETWEEN "'+ fromDate.query_date + '" AND "' + toDate.query_date + '" AND ' + conditionRow
  var report = AdsApp.report(query);  
  Logger.log("Report available at " + spreadsheet.getUrl());  
  var rows = report.rows(); 
  populateStatsDict(urlDict, accountDict, rows);  
}

function populateStatsDict(urlDict, accountDict, rows) {  
  while (rows.hasNext()) {  
    var row = rows.next();  
    var url = row['group_placement_view.target_url']; 
    var name = row['group_placement_view.display_name'];  
    if (!urlDict.hasOwnProperty(url)) { 
      urlDict[url] = [name];  
    } 
      
    var url = row["group_placement_view.target_url"]; 
    if (!accountDict.hasOwnProperty(url)) { 
      accountDict[url] = {  
        "group_placement_view.placement_type": row["group_placement_view.placement_type"],  
        "group_placement_view.display_name": row["group_placement_view.display_name"],  
        "group_placement_view.placement": row["group_placement_view.placement"],  
        "group_placement_view.target_url": row["group_placement_view.target_url"],  
        "metrics.impressions": 0, 
        "metrics.cost_micros": 0, 
        "metrics.conversions": 0, 
        "metrics.video_views": 0,
        'metrics.video_view_rate': 0, 
        'metrics.clicks': 0, 
        'metrics.average_cpm': 0, 
        'metrics.ctr' : 0 
      };  
      accumulateReportRow(row, accountDict[url]); 
    } 
    
  } 
}

function accumulateReportRow(row, acc) {  
  acc["metrics.impressions"] += toFloat(row['metrics.impressions']);  
  acc["metrics.cost_micros"] += toFloat(row['metrics.cost_micros']) / 10000; 
  acc["metrics.conversions"] += toFloat(row['metrics.conversions']);  
  acc["metrics.video_views"] += toFloat(row['metrics.video_views']);  
  acc['metrics.video_view_rate'] += toFloat(row['metrics.video_view_rate']);  
  acc['metrics.clicks'] += toFloat(row['metrics.clicks']);  
  acc['metrics.average_cpm'] += toFloat(row['metrics.average_cpm']);  
  acc['metrics.ctr'] += toFloat(row['metrics.ctr']);  
}

function toFloat(value) {
  if (!value) return 0;
  value = value.toString().replace(/,/g, '');
  return parseFloat(value);
}


function sendEmail(urlDict) {
  emails = (spreadsheet.getRangeByName(currentCustomerId + '!' + CONSTS_GAds.EMAILS)).getValue();
  //Logger.log("JSON.stringify(urls) = "+JSON.stringify(results));
  var urls = Object.keys(urlDict);

  if (urls.length == 0) {
    Logger.log('No alerts triggered. No email being sent.');
    return;
  }
  if (urls.length > 200) {
    Logger.log('Sending Email with a link to spreadsheet');
    MailApp.sendEmail(
      {
        to: emails,
        subject: EMAIL_SUBJECT,
        htmlBody:
          "<h1> Full spreadsheet: </h1><br>" +
          SPREADSHEET_URL
      });
  }
  else if (urls.length > 0) {
    var urlsAndNames = urls.map(function (key) { return key + " " + urlDict[key]; }).join("<br>");
    Logger.log('Sending Email');
    MailApp.sendEmail(
      {
        to: emails,
        subject: EMAIL_SUBJECT,
        htmlBody:
          "<h1> Channels to exclude: </h1><br>" +
          urlsAndNames + "<br>" +
          "<h1>Copy these urls to the exclusion list: </h1><br>" +
          urls.join("<br>") + "<br><br>" +
          'Full report:' +
          SPREADSHEET_URL
      });
  }
}

function writeDataToGoogleSheet(data, sheet) {
  var newDataRows = [];
  var headers = ["None"];
  for (var i in data) {
    var item = data[i];
    headers = Object.keys(item);
    break;
  }
  for (var i in data) {
    var item = data[i];
    newDataRows[i] = Object.keys(item).map(function (key) {
      return item[key];
    });
  }

  // Set headers
  // Translate API syntax to human syntax for headers
  headers = headers.map(x => METRICS_DICTIONARY[x.split(".").pop()]);
  headersRange = spreadsheet.getRangeByName(currentCustomerId + "!" + CONSTS_GAds.HEADERS);
  channelIdsHeader = spreadsheet.getRangeByName(currentCustomerId + "!" + CONSTS_GAds.CHANNEL_IDS_HEADER);
  range = sheet.getRange(headersRange.getRow(), headersRange.getColumn(), 1, headers.length);
  range.setValues([headers]);

  var newStartingRow = sheet.getLastRow() + 1;

  if (Object.keys(newDataRows).length > 0) {
    //Get Channel IDs of channels already in the output table
    var previousChannelIds = spreadsheet.getRangeByName(currentCustomerId + "!" + CONSTS_GAds.CHANNEL_IDS_COL).getValues().filter(String).flat();
    var deduplicatedChannelIds = [];
    var adsDataStatusRange = spreadsheet.getRangeByName(currentCustomerId + "!" + CONSTS_GAds.ADS_DATA_STATUS)
    adsDataStatusRange.setValue("");
    //Only add Channel IDs that aren't already in the output table
    for (let i = 0; i < Object.keys(newDataRows).length; i++) {
      if (!(previousChannelIds.includes((Object.entries(newDataRows)[i][1][headers.indexOf(channelIdsHeader.getValue())])))) {
        deduplicatedChannelIds.push(Object.values(newDataRows)[i]);
      }
      else {
        //Reset YT Data timestamp for this channel already in output table so that we'll fetch YT Data for this reappearing channel again
        //J is position within CHANNEL_IDS named range, need to add number of rows above it to get cell location of YT Data timestamp to be cleared
        var previousChannelColumn = spreadsheet.getRangeByName(currentCustomerId + "!" + CONSTS_GAds.CHANNEL_IDS_COL).getValues().filter(String);
        var channelIdsFirstRow = spreadsheet.getRangeByName(currentCustomerId + "!" + CONSTS_GAds.CHANNEL_IDS_COL).getRow();
        for (var j = 0; j < previousChannelColumn.length; j++){
          if (previousChannelColumn[j][0] === (Object.entries(newDataRows)[i][1][headers.indexOf(channelIdsHeader.getValue())])) {
            sheet.getRange(j+channelIdsFirstRow,spreadsheet.getRangeByName(currentCustomerId + "!" + CONSTS_GAds.YOUTUBE_TIMESTAMP_COL).getColumn(),1,1).clear();
          }
        }
        //There were no new channels added but there reappearing channels that new YT metadata should be added to
        adsDataStatusRange.setValue("GAds added new data!");
      }
    }
    //If there were new channels added, append to the end of the output results table in spreadsheet
    if (deduplicatedChannelIds.length > 0) {
    range = sheet.getRange(newStartingRow, headersRange.getColumn(), deduplicatedChannelIds.length, Object.values(newDataRows)[0].length);
    range.setValues(deduplicatedChannelIds);
    adsDataStatusRange.setValue("GAds added new data!");
    }    
  }
}
